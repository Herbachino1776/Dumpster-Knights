<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Junkyard Dungeon — TV-17</title>
<style>
  * { -webkit-tap-highlight-color: transparent; user-select:none; touch-action:none; }
  html,body { margin:0; height:100%; background:#000; }
  #game { display:block; margin:0 auto; background:#111; image-rendering: pixelated; }
  #hud {
    position:absolute; left:8px; top:8px; right:8px;
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    font:14px system-ui; color:#fff; text-shadow:0 2px 6px #000;
  }
  .pill { padding:3px 8px; border-radius:8px; background:rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.15); }
  #bossbar {
    position:absolute; left:50%; top:8px; transform:translateX(-50%);
    width:min(90vw,620px); height:12px; background:rgba(0,0,0,.35); border:1px solid #222; display:none;
  }
  #bossfill { height:100%; width:100%; background:#ff3b3b; }
  #msg {
    position:absolute; left:50%; top:28px; transform:translateX(-50%);
    color:#fff; font:16px/1.3 system-ui; text-shadow:0 2px 6px #000; pointer-events:none;
  }
  #buttons { position:absolute; bottom:12px; left:12px; right:12px; display:flex; gap:10px; }
  .btn {
    flex:1; padding:12px 14px; border:none; border-radius:12px;
    background:rgba(255,255,255,.25); color:#000; font:600 16px system-ui; box-shadow:0 2px 0 rgba(0,0,0,.25);
  }
  .btn:active { background:rgba(255,255,255,.45); }
  #overlay {
    position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column;
    color:#fff; text-shadow:0 2px 6px #000; background:rgba(0,0,0,.55); font:20px system-ui;
  }
  #overlay .big { font-size:34px; margin-bottom:10px; }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>

<div id="hud">
  <div id="room" class="pill">Room 1</div>
  <div id="hp"   class="pill">HP 100</div>
  <div id="wpn"  class="pill">Fists</div>
  <div id="tip"  class="pill">Tap to move • Attack to swing</div>
</div>
<div id="bossbar"><div id="bossfill"></div></div>
<div id="msg"></div>

<div id="buttons">
  <button id="btnAttack" class="btn">Attack</button>
  <button id="btnDodge"  class="btn">Dodge</button>
</div>

<div id="overlay">
  <div class="big" id="overTitle">You Fell</div>
  <div id="overSub">Tap Retry</div>
  <button id="retry" class="btn" style="width:220px; margin-top:12px;">Retry</button>
</div>

<script>
(()=>{
// ---------- ASSET PATHS ----------
const PATHS = {
  backgrounds: [
    {src:'assets/backgrounds/arena_junkyard_800x400.jpg', label:'Junkyard'},
    {src:'assets/backgrounds/arena_dark_alley_800x400.jpg', label:'Dark Alley'},
    {src:'assets/backgrounds/arena_fortress_800x400.jpg', label:'Scrap Fortress'}
  ],
  player:'assets/sprites/player/player_idle_1.png',
  thug:  'assets/sprites/enemies/street_thug_idle_1.png',
  boss:  'assets/sprites/bosses/junkyard_warlord.png',
  thermos:'assets/sprites/items/thermos_health.png',
  sword: 'assets/sprites/items/dumpster_sword.png'
};

// ---------- DOM ----------
const c = document.getElementById('game'), ctx = c.getContext('2d');
const W = c.width, H = c.height;
const roomEl = document.getElementById('room');
const hpEl   = document.getElementById('hp');
const wpnEl  = document.getElementById('wpn');
const msgEl  = document.getElementById('msg');
const btnAttack = document.getElementById('btnAttack');
const btnDodge  = document.getElementById('btnDodge');
const overlay   = document.getElementById('overlay');
const retryBtn  = document.getElementById('retry');
const bossbar   = document.getElementById('bossbar');
const bossfill  = document.getElementById('bossfill');

ctx.imageSmoothingEnabled = false;

// ---------- LOADER ----------
function loadImage(src){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=()=>res(null); i.src=src; }); }
const ASSETS = { backgrounds:[] };
Promise.all([
  ...PATHS.backgrounds.map(b=>loadImage(b.src)),
  loadImage(PATHS.player),
  loadImage(PATHS.thug),
  loadImage(PATHS.boss),
  loadImage(PATHS.thermos),
  loadImage(PATHS.sword),
]).then(imgs=>{
  const bgs = imgs.slice(0,PATHS.backgrounds.length);
  ASSETS.backgrounds = bgs.map((img,i)=>({img,label:PATHS.backgrounds[i].label}));
  ASSETS.player  = imgs[PATHS.backgrounds.length+0];
  ASSETS.thug    = imgs[PATHS.backgrounds.length+1];
  ASSETS.boss    = imgs[PATHS.backgrounds.length+2];
  ASSETS.thermos = imgs[PATHS.backgrounds.length+3];
  ASSETS.sword   = imgs[PATHS.backgrounds.length+4];
  init();
  requestAnimationFrame(loop);
});

// ---------- STATE ----------
let running = true;
let messageT = 0;

const player = {
  x: 100, y: H-120, w:64, h:96,
  hp:100, speed:160, dest:null, face:1,
  hasSword:false, atkCD:0, atkWin:0, dodgeCD:0, iFrames:0
};

let roomNum = 1;
let bgIndex = 0;
let enemies = [];   // thugs
let pickups = [];   // thermos/sword
let particles = []; // hit sparks, blood globs (tiny, quick)
let boss = null;    // {x,y,w,h,hp,max,atkCd,patternT}

function say(t, ms=1000){ msgEl.textContent=t; messageT=ms/1000; }

// ---------- ROOM GEN ----------
function init(){
  startRun();
  // input
  c.addEventListener('pointerdown',(e)=>{
    if(!running) return;
    const r=c.getBoundingClientRect();
    const x=e.clientX-r.left, y=e.clientY-r.top;
    player.dest = {
      x: Math.max(0, Math.min(W-player.w, x-player.w/2)),
      y: Math.max(0, Math.min(H-player.h, y-player.h/2))
    };
    player.face = Math.sign((x - (player.x+player.w/2))) || 1;
  });
  btnAttack.addEventListener('pointerdown', ()=>{ if(!running) return; if(player.atkCD<=0){ player.atkWin=0.16; player.atkCD=0.35; } });
  btnDodge.addEventListener('pointerdown',  ()=>{ if(!running) return; if(player.dodgeCD<=0){ player.iFrames=0.35; player.dodgeCD=1.0;
                                                    player.x += player.face*40; } });
  retryBtn.addEventListener('pointerdown', ()=>{ overlay.style.display='none'; startRun(); });
}

function startRun(){
  running = true;
  messageT = 0;
  roomNum = 1; bgIndex = 0;
  player.x=100; player.y=H-120; player.hp=100; player.hasSword=false; player.atkCD=0; player.atkWin=0; player.dodgeCD=0; player.iFrames=0;
  particles.length=0;
  buildRoom();
  updateHUD();
}

function buildRoom(){
  enemies.length=0; pickups.length=0; boss=null;
  const bg = ASSETS.backgrounds[bgIndex];
  roomEl.textContent = `Room ${roomNum} — ${bg ? bg.label : 'Zone'}`;

  // spawn enemies
  const count = Math.min(6, 2 + Math.floor(roomNum*0.8));
  for(let i=0;i<count;i++){
    let ex,ey;
    do{
      ex = 160 + Math.random()*(W-220);
      ey = 60  + Math.random()*(H-140);
    }while(Math.hypot((ex-player.x),(ey-player.y))<100);
    enemies.push({x:ex,y:ey,w:64,h:96,hp:3,pat:0,t:Math.random()*2});
  }

  // occasional pickups
  if(Math.random()<0.6) pickups.push({type:'thermos',x: 100+Math.random()*(W-180), y:60+Math.random()*(H-140), w:48, h:48});
  if(!player.hasSword && Math.random()<0.5) pickups.push({type:'sword',x: 140+Math.random()*(W-220), y:60+Math.random()*(H-160), w:48,h:48});

  // boss every 4th room
  if(roomNum % 4 === 0){
    const bx = W-200, by = 80;
    boss = { x:bx, y:by, w:96, h:128, hp:220, max:220, atkCd:1.2, patternT:0 };
    bossbar.style.display='block';
    bossfill.style.width='100%';
    say('Boss Approaches', 900);
  } else {
    bossbar.style.display='none';
  }
}

// ---------- HELPERS ----------
function overlap(a,b){
  return a.x < b.x + (b.w||48) && a.x + (a.w||64) > b.x &&
         a.y < b.y + (b.h||48) && a.y + (a.h||96) > b.y;
}
function updateHUD(){
  hpEl.textContent  = `HP ${Math.round(player.hp)}`;
  wpnEl.textContent = player.hasSword ? 'Sword' : 'Fists';
}

// ---------- LOOP ----------
let last=0;
function loop(ts){
  const dt = Math.min(0.033, (ts-last)/1000 || 0.016); last = ts;
  if(running) update(dt);
  draw();
  requestAnimationFrame(loop);
}

function update(dt){
  if(messageT>0){ messageT-=dt; if(messageT<=0) msgEl.textContent=''; }
  if(player.atkCD>0)  player.atkCD-=dt;
  if(player.atkWin>0) player.atkWin-=dt;
  if(player.dodgeCD>0) player.dodgeCD-=dt;
  if(player.iFrames>0) player.iFrames-=dt;

  // move player
  if(player.dest){
    const dx = player.dest.x - player.x, dy = player.dest.y - player.y;
    const d = Math.hypot(dx,dy), mv = player.speed * dt;
    if(d<=mv){ player.x=player.dest.x; player.y=player.dest.y; player.dest=null; }
    else { player.x += dx/d*mv; player.y += dy/d*mv; }
  }

  // enemies patrol + chase slightly
  enemies.forEach(e=>{
    e.t -= dt;
    if(e.t<=0){
      e.pat = (Math.random()*2-1); // horizontal bias
      e.t = 0.8 + Math.random()*1.2;
    }
    const dx = (player.x - e.x), dy = (player.y - e.y);
    const follow = 0.6; // 0..1
    e.x += (e.pat*40*dt) + (dx * 0.4 * follow * dt);
    e.y += (dy * 0.4 * follow * dt);
    e.x = Math.max(12, Math.min(W-76, e.x));
    e.y = Math.max(20, Math.min(H-116, e.y));

    // contact damage
    if(overlap(player,e) && player.iFrames<=0){
      player.hp = Math.max(0, player.hp - 20*dt);
      if(player.hp<=0){ death('You Fell'); }
    }
  });

  // boss AI
  if(boss){
    // simple drift towards player
    const dx = player.x - boss.x, dy = player.y - boss.y;
    const d  = Math.hypot(dx,dy)||1;
    boss.x += (dx/d)*40*dt; boss.y += (dy/d)*30*dt;

    // attack pattern: shockwave lob
    boss.atkCd -= dt;
    boss.patternT += dt;
    if(boss.atkCd<=0){
      boss.atkCd = 1.6;
      // shockwave = radial fragments
      for(let k=0;k<10;k++){
        const a = (k/10)*Math.PI*2;
        particles.push({x:boss.x+boss.w/2,y:boss.y+boss.h/2,vx:Math.cos(a)*120,vy:Math.sin(a)*120,life:0,max:0.7,col:'#ff5555',dmg:12});
      }
    }
    // boss contact hurts more
    if(overlap(player,boss) && player.iFrames<=0){
      player.hp = Math.max(0, player.hp - 40*dt);
      if(player.hp<=0){ death('Crushed by Warlord'); }
    }
    // boss bar
    bossfill.style.width = Math.max(0, (boss.hp/boss.max*100))+'%';
  }

  // attack window: hit enemies/boss in front
  if(player.atkWin>0){
    const ax = player.face>=0 ? player.x+player.w : player.x-24;
    const a = {x:ax, y:player.y+20, w:24, h:56};
    // hit thugs
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      if(overlap(a,e)){
        e.hp -= player.hasSword ? 2 : 1;
        particles.push({x:e.x+e.w/2,y:e.y+e.h/2,vx:(player.face>=0?60:-60),vy:-20,life:0,max:0.25,col:'#a00'});
        if(e.hp<=0) enemies.splice(i,1);
      }
    }
    // hit boss
    if(boss && overlap(a,boss)){
      boss.hp -= player.hasSword ? 4 : 2;
      particles.push({x:boss.x+boss.w/2,y:boss.y+30,vx:0,vy:-40,life:0,max:0.3,col:'#f33'});
      if(boss.hp<=0){
        boss=null; bossbar.style.display='none';
        say('Boss Down!', 1200);
        // drop goodies
        pickups.push({type:'thermos',x:W/2-60,y:H/2-24,w:48,h:48});
        pickups.push({type:'sword',x:W/2+12,y:H/2-24,w:48,h:48});
      }
    }
  }

  // pickups collect
  for(let i=pickups.length-1;i>=0;i--){
    const p=pickups[i];
    if(overlap(player,p)){
      if(p.type==='thermos'){ player.hp = Math.min(100, player.hp+40); say('+40 HP', 700); }
      else if(p.type==='sword'){ player.hasSword = true; say('Found Sword', 800); }
      pickups.splice(i,1);
      updateHUD();
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const P=particles[i];
    P.x += (P.vx||0)*dt; P.y += (P.vy||0)*dt; P.life+=dt;
    if(P.dmg && P.life<0.25 && overlap(player, {x:P.x-6,y:P.y-6,w:12,h:12}) && player.iFrames<=0){
      player.hp = Math.max(0, player.hp - P.dmg);
      player.iFrames = 0.25;
      if(player.hp<=0) death('You Fell');
    }
    if(P.life>P.max) particles.splice(i,1);
  }

  // room clear?
  const cleared = enemies.length===0 && !boss;
  if(cleared){
    // prompt to exit on right edge
    if(player.x > W-90){
      roomNum++;
      bgIndex = (bgIndex+1) % (ASSETS.backgrounds.length || 1);
      buildRoom();
    }
  }

  updateHUD();
}

function death(text){
  running=false;
  document.getElementById('overTitle').textContent = text;
  document.getElementById('overSub').textContent   = `Rooms Cleared: ${Math.max(0,roomNum-1)}`;
  overlay.style.display='flex';
}

// ---------- RENDER ----------
function draw(){
  ctx.clearRect(0,0,W,H);

  // background
  const bg = ASSETS.backgrounds[bgIndex];
  if(bg && bg.img){ ctx.drawImage(bg.img,0,0,W,H); }
  else { ctx.fillStyle='#333'; ctx.fillRect(0,0,W,H); }

  // exit arrow if cleared
  if(enemies.length===0 && !boss){
    ctx.fillStyle='rgba(255,255,0,.75)';
    ctx.fillRect(W-40, H-80, 24, 24);
  }

  // pickups
  for(const p of pickups){
    const img = (p.type==='thermos')? ASSETS.thermos : ASSETS.sword;
    if(img) ctx.drawImage(img, p.x, p.y, p.w, p.h);
    else { ctx.fillStyle = p.type==='thermos' ? '#ff6666' : '#ffd166'; ctx.fillRect(p.x,p.y,p.w,p.h); }
  }

  // enemies
  for(const e of enemies){
    if(ASSETS.thug) ctx.drawImage(ASSETS.thug, e.x, e.y, e.w, e.h);
    else { ctx.fillStyle='#8e44ad'; ctx.fillRect(e.x,e.y,e.w,e.h); }
  }

  // boss
  if(boss){
    if(ASSETS.boss) ctx.drawImage(ASSETS.boss, boss.x, boss.y, boss.w, boss.h);
    else { ctx.fillStyle='#d35400'; ctx.fillRect(boss.x,boss.y,boss.w,boss.h); }
  }

  // player
  if(ASSETS.player) ctx.drawImage(ASSETS.player, player.x, player.y, player.w, player.h);
  else { ctx.fillStyle='#2ecc71'; ctx.fillRect(player.x,player.y,player.w,player.h); }

  // attack swing / sword draw
  if(player.atkWin>0){
    // swing flash
    ctx.globalAlpha=.5; ctx.fillStyle='#ff0';
    const ax = player.face>=0 ? player.x+player.w : player.x-24;
    ctx.fillRect(ax, player.y+20, 24, 56);
    ctx.globalAlpha=1;
    // draw sword briefly if owned
    if(player.hasSword && ASSETS.sword){
      const sx = player.face>=0 ? player.x + player.w - 6 : player.x - 18;
      const sy = player.y + 40;
      ctx.save();
      ctx.translate(sx+12, sy+12);
      ctx.rotate((player.face>=0?1:-1)*0.45);
      ctx.translate(-12,-12);
      ctx.drawImage(ASSETS.sword, 0, 0, 24, 24);
      ctx.restore();
    }
  }

  // particles
  for(const P of particles){
    const a = 1 - (P.life/P.max);
    ctx.globalAlpha = Math.max(0,a);
    ctx.fillStyle = P.col || '#fff';
    ctx.fillRect(P.x-2, P.y-2, 4, 4);
    ctx.globalAlpha = 1;
  }
}
})();
</script>
</body>
</html>